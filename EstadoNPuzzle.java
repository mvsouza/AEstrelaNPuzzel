import java.util.LinkedList;
public class EstadoNPuzzle implements IEstado<int[][]>
{
	private int[][] Estado;
	private int Percorrido;
	private EstadoNPuzzle EstadoAnterior;
	private int Tamanho;
	private int PecaVazia;
	public String Movimento;
	
	public EstadoNPuzzle(int[][] Estado,int Tamanho,String Movimento,int Percorrido, EstadoNPuzzle EstadoAnterior)
	{
		this.Percorrido=Percorrido;
		this.Movimento=Movimento;
		this.Tamanho=Tamanho;
		this.Estado=Estado;
		this.EstadoAnterior=EstadoAnterior;
		this.PecaVazia=0;
	}
	/**
	 * Returns the height and width of puzzle board(they are the same).
	 * @return
	 */
	public int getTamanho()	{return Tamanho;}
	public int getPercorrido(){	return Percorrido;	}
	public IEstado<int[][]> getEstadoAnterior()	{return EstadoAnterior;}
	public int[][] getEstado() { return clone(Estado); }
	public int CalcEuristica(int[][] EstadoFinal)
	{
		int aux = 0;
		for(int i = 0;i<Tamanho;i++)
		{
			for(int j = 0; Tamanho>j;j++)
			{
				Position aux2 = getPosition(EstadoFinal,Estado[i][j]);
				aux+=aux2.getY()>i?aux2.getY()-i:i-aux2.getY();
				aux+=aux2.getX()>j?aux2.getX()-j:j-aux2.getX();
			}
		}
		return aux;
	}
	public boolean equals(IEstado<int[][]> e){
		int[][] s0 = e.getEstado();
		for(int j = 0; j<s0.length;j++)
			for(int i = 0;i<s0[j].length;i++)
				if(s0[j][i]!=Estado[j][i]) return false;
		return true;
	}
	public LinkedList<IEstado<int[][]>> Visinhos(){
		LinkedList<IEstado<int[][]>> retorno = new LinkedList<IEstado<int[][]>>();
		Position posicaoPeca = getPosition(Estado, PecaVazia);
		if(posicaoPeca.getX()+1<Tamanho)retorno.add(move("right",posicaoPeca));
		if(0<posicaoPeca.getX())		retorno.add(move("left",posicaoPeca));
		if(posicaoPeca.getY()+1<Tamanho)retorno.add(move("down",posicaoPeca));
		if(0<posicaoPeca.getY())		retorno.add(move("up",posicaoPeca));
		return retorno;
	}
	/**
	 * Returns an EstadoNPuzzelm generated by an specific  movement from a tile to a direction.
	 * @param side The direction of the movement.
	 * @param p The position from the tile which will be moved.
	 * @return
	 */
	public EstadoNPuzzle move(String side, Position p){
		int[][] aux = clone(Estado);
		switch(side)
		{
			case "up":
				aux[p.getY()][p.getX()]=Estado[p.getY()-1][p.getX()];
				aux[p.getY()-1][p.getX()]=Estado[p.getY()][p.getX()];
				break;
			case "down":
				aux[p.getY()][p.getX()]=Estado[p.getY()+1][p.getX()];
				aux[p.getY()+1][p.getX()]=Estado[p.getY()][p.getX()];
				break;
			case "right":
				aux[p.getY()][p.getX()]=Estado[p.getY()][p.getX()+1];
				aux[p.getY()][p.getX()+1]=Estado[p.getY()][p.getX()];
				break;
			case "left":
				aux[p.getY()][p.getX()]=Estado[p.getY()][p.getX()-1];
				aux[p.getY()][p.getX()-1]=Estado[p.getY()][p.getX()];
				break;
		}
		return new EstadoNPuzzle(aux,Tamanho,side,Percorrido+1,this);
	}
	/**
	 * Returns the position from the given value on the matrix.
	 * @param s0 The matrix to do search.
	 * @param p The value to be search.
	 * @return
	 */
	public Position getPosition(int[][] s0, int n){
		for(int i = 0;i<Tamanho;i++)
			for(int j = 0; Tamanho>j;j++)
				if(n==s0[i][j])
					return new Position(j,i);
		return null;
	}
	/**
	 * Returns a reference from an identical instance from the matrix passed.
	 * @param s0 The matrix to be cloned.
	 * @return
	 */
	public int [][] clone(int [][]s0)
	{
		int[][] clonado =  new int [Tamanho][];
		for(int j = 0; j<s0.length;j++)
		{
			clonado[j] = new int[Tamanho];
			for(int i = 0;i<Tamanho;i++)
				clonado[j][i] = s0[j][i];
		}
		return clonado;
	}
	public boolean isSolvable(IEstado<int[][]> EstadoFinal) {
		int[][] inicialM =  Estado;
		int[][] goalM =  EstadoFinal.getEstado();
		int[] inicial =  new int[Tamanho*Tamanho];
		int[] goal =  new int[Tamanho*Tamanho];
		for(int i = 0;i<Tamanho;i++)
		{
			for(int j = 0;j<Tamanho;j++)
			{
				inicial[j+i*Tamanho]=inicialM[i][j];
				goal[j+i*Tamanho]=goalM[i][j];
			}
		}
		int aux = 0;
		Position p = getPosition(Estado,PecaVazia);
		for(int i = 0;i<Tamanho*Tamanho-1;i++)
		{
			int cont = 0;
			for(int j = i; inicial[j]==j;j++)
			{
				int aux2 = inicial[j];
				inicial[j]=inicial[j+1];
				inicial[j+1]=aux2;
				cont++;
			}
			aux+=cont;
		}
		return ( (Tamanho%2==1) && (aux%2==0) )  ||  ( (Tamanho%2==0 && ((Tamanho-p.getY()%2==1) == (aux%2==0)) ));
	}
	public void printEstado()
	{
        String aux = "";
        for(int i = 0;i<Estado.length;i++)
        {
			for(int j = 0;j<Estado[i].length;j++)
			{
				aux+=Estado[i][j];
				if(j%3!=2)
				{
					aux+="|";
				}
			}
			aux+="\n-+-+-\n";
        }
		System.out.println(aux);
    }
	public int heuristicHemming(int [][]s0) {
		int aux = 0;
		for(int i = 0;i<s0.length;i++)
		{
			for(int j = i; s0[i].length>j;j++)
			{
				if(s0[i][j]!=i*3+j)aux++;
			}
		}
		return aux;
	}
}